Мы создадим игру шашки для двух игроков. Основные правила:

1. Игровое поле 8x8.

2. Шашки ходят по диагонали вперед на одну клетку.

3. Если перед шашкой противника есть пустая клетка за ней, то шашка может "съесть" шашку противника, перепрыгнув через нее.

4. При достижении последнего ряда (для белых - 0-я строка, для черных - 7-я строка) шашка становится дамкой. Дамка может ходить по диагонали в любом направлении на любое количество клеток.

5. Есть правило "турецкого удара": если есть несколько вариантов взятия, то игрок может выбрать любой, но если в одном направлении можно взять несколько шашек, то нужно бить до конца.

6. При съедании шашки противника, если после съедения с той же позиции можно съесть еще, то ход продолжается (множественное взятие).

План:

1. Создадим класс `Checker` (шашка) с атрибутами: цвет и является ли дамкой.

2. Создадим класс `Board` (доска), который будет содержать состояние доски (двумерный список 8x8).

- Изначально расставим шашки: в строках 0-2 - белые, 5-7 - черные (белые начинают сверху, черные снизу).

- Белые шашки: 'W', белые дамки: 'W_king'

- Черные шашки: 'B', черные дамки: 'B_king'

3. Класс `Game` будет управлять ходом игры: чередование ходов, проверка правильности хода, обработка взятий, проверка победы.

Реализация:

- Доска: индекс [0][0] - верхний левый угол (для белых это их тыл).

- Ход белых: сначала они ходят вниз (строки увеличиваются), черных - вверх (строки уменьшаются).

Важно:

- При ходе необходимо проверять, есть ли у игрока обязательные взятия. Если есть, то он должен бить, а не ходить просто.

- При множественном взятии нужно запоминать позицию, с которой начали взятие, и продолжать только оттуда (но в рамках одного хода).

Мы сделаем:

- `Board` будет иметь методы:

* `__init__` - инициализация доски.

* `print_board` - печать доски (для отладки и игры в консоли).

* `get_piece` - получить шашку по позиции.

* `move` - переместить шашку с одной позиции на другую (с проверкой правил, но проверку вынесем в Game?).

* `remove_piece` - удалить шашку (при взятии).

* `get_valid_moves` - для заданной шашки (позиции) получить все возможные ходы (с учетом взятий, если они обязательны).

- `Game` будет иметь:

* `__init__` - создает доску, устанавливает текущего игрока (белые начинают).

* `play` - основной цикл игры.

* `handle_turn` - обработка хода игрока.

Однако, учитывая сложность, мы можем объединить логику в классе `Board` для вычисления допустимых ходов.

Особенность: при наличии нескольких взятий, игрок может выбрать любое из них, но если в одном направлении можно бить несколько, то нужно бить по цепочке.

Алгоритм для `get_valid_moves`:

1. Сначала проверим, есть ли для текущего игрока какие-либо взятия на всей доске. Если есть, то разрешаем только ходы, которые включают взятие.

2. Для конкретной шашки (если мы уже выбрали шашку) ищем все возможные взятия (рекурсивно, так как может быть несколько шашек подряд).

3. Для дамок: они могут перемещаться на несколько клеток, но при взятии могут перепрыгивать только через одну шашку за раз, и приземляться на любую пустую клетку за ней, а затем продолжать взятие в любом диагональном направлении.

Реализация может быть сложной, поэтому начнем с базовых шашек (не дамок).

Этапы:

1. Создадим доску и возможность поочередных ходов без взятий и дамок.

2. Добавим взятия.

3. Добавим дамки.

4. Добавим множественные взятия.

Для простоты отображения будем использовать:

'.' - пустая клетка

'W' - белая шашка

'B' - черная шашка

'W_king' - белая дамка (будем отображать как 'WK')

'B_king' - черная дамка (будем отображать как 'BK')

Однако в коде будем хранить как строки.

Структура:

class Checker:

def __init__(self, color, king=False):

self.color = color

self.king = king

def __repr__(self):

if self.king:

return self.color[0] + 'K'

return self.color[0]

Но для простоты, мы не будем создавать отдельный класс, а будем использовать строки.

Вместо этого, в доске будем хранить:

board[row][col] = None или строку:

'w' - белая шашка

'b' - черная шашка

'W' - белая дамка

'B' - черная дамка

Или:

шашки: 'w', 'b'

дамки: 'W', 'B'

Тогда при достижении последнего ряда, мы превращаем шашку в дамку.

Движение:

Для белой шашки (не дамки): может двигаться на (row-1, col-1) и (row-1, col+1) если они в пределах доски и пусты.

Для черной шашки: (row+1, col-1) и (row+1, col+1).

Взятие:

Для белой: через (row-1, col±1) если там черная, а за ней (row-2, col±2) пусто. Тогда можно съесть.

Аналогично для черной: через (row+1, col±1) если там белая, а за ней (row+2, col±2) пусто.

Для дамки: может двигаться по диагонали на любое количество клеток, пока не встретит препятствие. При взятии: должна перепрыгнуть через вражескую шашку (только одну) и приземлиться на следующую за ней по диагонали (и затем может продолжить в том же направлении, если есть еще враги, но с пустыми клетками за ними).

Множественное взятие: после первого взятия, с новой позиции шашка (или дамка) может снова бить.

Важно: при наличии нескольких цепочек, игрок может выбрать любую.

Как будем представлять ход?

Ход - это список перемещений (для простых шашек - один шаг, для взятий - несколько прыжков). Но игрок вводит начальную позицию и конечную. Однако при множественном взятии, после первого прыжка, игрок должен продолжать с той же шашки, пока есть возможность бить.

Поэтому, в нашей реализации, после выбора шашки, мы покажем все возможные ходы (цепи) для нее. Игрок выбирает конечную позицию, а мы автоматически проходим по всей цепочке.

Но в консоли это сложно, поэтому мы будем запрашивать у игрока последовательность прыжков? Или просто конечную точку?

Альтернатива: при наличии взятия, игрок должен бить, и если после первого взятия есть еще взятия, то он обязан их сделать. Поэтому мы будем обрабатывать один ход как цепочку прыжков.

Поэтому, в `get_valid_moves` для выбранной шашки мы вернем словарь:

ключ - конечная позиция (row, col)

значение - список шагов (промежуточных позиций, которые будут "съедены")

Но цепочка может иметь несколько ветвей. Поэтому мы должны вернуть все возможные полные цепочки?

Мы сделаем так: функция `get_valid_moves` будет возвращать список возможных ходов. Каждый ход - это список позиций, которые пройдёт шашка (включая начальную и конечные). При простом ходе: [ (start_row, start_col), (end_row, end_col) ]. При взятии: [ (start, jump1, jump2, ...) ].

Но для каждой шашки мы можем иметь несколько цепочек. Поэтому мы вернем список списков позиций.

Однако, это может быть сложно. Упростим: будем возвращать словарь, где ключ - конечная позиция, а значение - список съеденных шашек (позиций) при движении к этой конечной позиции.

Но при множественном взятии, одна конечная позиция может быть достигнута разными путями? Да, но в шашках при взятии обычно путь определяется направлением. Поэтому для одной шашки мы можем иметь несколько конечных позиций.

Мы реализуем функцию, которая рекурсивно собирает все возможные цепочки для шашки (начиная с ее позиции) в рамках одного хода (только взятия). Если взятий нет, то возвращаем простые ходы.

Псевдокод для `get_jumps` (рекурсивный):

jumps_list = []   # список всех цепочек (каждая цепочка - список позиций, по которым проходит шашка: [start, pos1, pos2, ... end])

def dfs(current, path, captured):

current - текущая позиция (row, col)

path - список уже пройденных позиций (включая начальную)

captured - множество уже съеденных шашек (позиций)

найдем все возможные прыжки из current (которые не ведут на уже съеденные шашки)

для каждого возможного прыжка:

новая позиция = current + (2*dr, 2*dc)  (перепрыгиваем через врага)

враг = позиция (current[0]+dr, current[1]+dc)

если прыжок возможен (враг есть и он противника, и новая позиция пуста и не была в path) и враг не в captured?

но враг не должен быть съеден ранее в этом ходе? в одном ходе нельзя дважды съесть одну шашку.

Поэтому, мы помечаем съеденных врагов в captured.

Если мы нашли прыжок, то добавляем его в path, и рекурсивно вызываем dfs из новой позиции.

Если прыжков не найдено, то добавляем текущий path в jumps_list.

Начинаем: dfs(start, [start], set())

Возвращаем jumps_list.

Для дамки: прыжок может быть на несколько клеток? Нет, прыжок дамки тоже только через одну шашку. Но после прыжка дамка может двигаться дальше по диагонали, если есть еще враги. Поэтому для дамки алгоритм похож, но нужно проверить все диагональные направления и в каждом направлении искать первую вражескую шашку (и за ней пустые клетки, на которые можно приземлиться и продолжить взятие).

Для простой шашки: только на 2 клетки.

Для дамки: при взятии, она может перепрыгнуть врага на любую клетку за ним по диагонали (но только одного врага за раз). Поэтому для дамки прыжок - это ровно 2 клетки? Нет, дамка может переместиться на несколько клеток за врагом?

По правилам: дамка при взятии перепрыгивает вражескую шашку и становится на любую свободную клетку за ней по диагонали, после чего может продолжать взятие. Но при этом за один прыжок снимается только одна шашка. Поэтому для дамки мы разбиваем движение: ищем по диагонали до первой вражеской шашки (пустые клетки проходим). Когда нашли врага, то за ним должны быть пустые клетки. Тогда мы можем выбрать любую пустую клетку за врагом в этом направлении? Нет, обычно только до следующей шашки. Но по правилам: дамка должна остановиться сразу за побитой шашкой?

На самом деле, в международных шашках (и в русских тоже) дамка после взятия шашки противника становится на любую свободную клетку диагонально за побитой шашкой, и с этой клетки может продолжить взятие. Поэтому для дамки прыжок - это не обязательно соседняя клетка, а любая за врагом.

Однако, для упрощения, мы будем искать все возможные прыжки для дамки: в каждом из 4 диагональных направлений, ищем первую шашку противника. Когда находим, то смотрим, что за ней есть пустые клетки. Тогда мы можем перепрыгнуть и встать на любую пустую клетку за ней. И с этой позиции продолжать взятие.

Это сложно, поэтому начнем с простых шашек.

Из-за сложности, мы сначала реализуем базовую версию без дамок и без множественных взятий, а потом расширим.

План реализации:

Этап 1:

- Доска 8x8, начальная расстановка.

- Ходы без взятий и без дамок.

- Проверка, что шашка ходит правильно.

Этап 2:

- Добавляем взятие одной шашки.

Этап 3:

- Множественное взятие для обычных шашек.

Этап 4:

- Добавляем превращение в дамку.

Этап 5:

- Добавляем ходы дамки (без взятий).

Этап 6:

- Добавляем взятия дамкой.

Этап 7:

- Множественное взятие дамкой.

Но это очень большой объем. Поэтому сделаем базовую версию с простыми шашками и взятиями (одиночными) и дамками без множественных взятий.

Из-за ограниченного времени, мы сделаем упрощенную версию:

Для обычных шашек:

- Ход: перемещение на одну клетку по диагонали вперед.

- Взятие: прыжок через одну шашку противника (только на 2 клетки) и удаление врага.

Для дамок:

- Ход: перемещение на любое количество клеток по диагонали (как слон в шахматах, но без взятий).

- Взятие: дамка может перепрыгнуть шашку противника, если за ней есть пустая клетка (только через одну шашку) и затем может встать на любую клетку за ней? Но по правилам, дамка после взятия может встать на любую свободную клетку за побитой шашкой. И с этой клетки продолжить взятие. Но мы пока не будем делать множественное взятие.

Игровой процесс:

- Игроки по очереди.

- В начале хода проверяем, есть ли у текущего игрока обязательные взятия. Если есть, то игрок должен выбрать ход, который включает взятие.

- Игрок вводит начальную и конечную позицию.

Реализация:

Класс Board:

def __init__(self):

self.board = [[None] * 8 for _ in range(8)]

self.setup_board()

def setup_board(self):

# Расставляем черные шашки (игрок внизу) - на строках 5,6,7

for row in range(3):

for col in range(8):

if (row + col) % 2 == 1:

self.board[row][col] = 'b'   # черные вверху? Нет, по условию: белые в строках 0-2, черные в 5-7.

for row in range(5, 8):

for col in range(8):

if (row + col) % 2 == 1:

self.board[row][col] = 'w'

# Но обычно: белые снизу? Давайте пересмотрим.

# Мы решили: белые начинают сверху (строки 0-2), черные снизу (5-7). Тогда:

#   белые (игрок 1) ходят вниз (увеличивая row), черные (игрок 2) ходят вверх (уменьшая row).

# Но в коде: вверху доски row=0, внизу row=7.

# Поэтому для белых: их шашки вверху (строки 0,1,2) - они ходят вниз.

# Для черных: строки 5,6,7 - ходят вверх.

# Но в нашей расстановке: белые шашки мы обозначили как 'w', а черные как 'b'.

# Но тогда игрок 1 (белые) управляет 'w', а игрок 2 (черные) - 'b'.

# Однако, в коде выше мы поставили внизу (строки 5-7) белые? Нет, мы поставили на строках 5-7 - 'w', а на 0-2 - 'b'.

# Это неправильно. Исправим:

# Очистим

self.board = [[None] * 8 for _ in range(8)]

# Белые (игрок 1) - вверху (строки 0,1,2) - обозначим 'w'

for row in range(3):

for col in range(8):

if (row + col) % 2 == 1:

self.board[row][col] = 'w'

# Черные (игрок 2) - внизу (строки 5,6,7) - обозначим 'b'

for row in range(5, 8):

for col in range(8):

if (row + col) % 2 == 1:

self.board[row][col] = 'b'

def move(self, start, end):

# Перемещает шашку из start в end.

# Если при этом было взятие, то удаляем шашку противника.

# Пока без взятия.

start_row, start_col = start

end_row, end_col = end

piece = self.board[start_row][start_col]

self.board[start_row][start_col] = None

self.board[end_row][end_col] = piece

# Если шашка дошла до последнего ряда, делаем ее дамкой.

if piece == 'w' and end_row == 7:

self.board[end_row][end_col] = 'W'   # дамка белых

elif piece == 'b' and end_row == 0:

self.board[end_row][end_col] = 'B'   # дамка черных

def get_jumps_for_piece(self, row, col, player):

# Для простой шашки: проверим 4 направления? Но для белых и черных направления разные.

# player: 'w' или 'b'

piece = self.board[row][col]

if piece is None:

return []

jumps = []   # каждый прыжок: ((end_row, end_col), (jumped_row, jumped_col))

# Определим направления для белых и черных

if player == 'w' or piece == 'W':  # белая шашка или дамка

directions = [(-1, -1), (-1, 1)]

if player == 'b' or piece == 'B':

directions = [(1, -1), (1, 1)]

if piece in ['W', 'B']: # дамка

directions = [(-1,-1), (-1,1), (1,-1), (1,1)]

# Для дамки мы должны рассмотреть каждое направление до края доски?

# Но для прыжка дамки: мы ищем в направлении первую шашку противника, а за ней пустые клетки.

# Пока реализуем только для обычных шашек.

if piece in ['w', 'b']:

for dr, dc in directions:

r, c = row + dr, col + dc

if 0 <= r < 8 and 0 <= c < 8:

if self.board[r][c] and self.board[r][c].lower() != player: # вражеская шашка

# За врагом должна быть пустая клетка

r2, c2 = r + dr, c + dc

if 0 <= r2 < 8 and 0 <= c2 < 8 and self.board[r2][c2] is None:

jumps.append(((r2, c2), (r, c)))

else:

# Для дамки

for dr, dc in directions:

# Идем по направлению, пока не встретим шашку

r, c = row + dr, col + dc

found_opponent = False

jump_pos = None

while 0 <= r < 8 and 0 <= c < 8:

if self.board[r][c] is None:

if found_opponent:

# За врагом пустая клетка - можем прыгнуть

jumps.append(((r, c), jump_pos))

# идем дальше

r += dr

c += dc

continue

# Если нашли шашку

if self.board[r][c].lower() == player: # своя шашка

break

else: # вражеская шашка

if found_opponent:

break   # уже нашли врага, и теперь вторая - нельзя перепрыгнуть двух

found_opponent = True

jump_pos = (r, c)

# Продолжим движение, чтобы найти пустую клетку за врагом

r += dr

c += dc

# Конец while

return jumps

def get_valid_moves(self, player):

# player: 'w' или 'b'

# Сначала проверим, есть ли обязательные взятия

jumps_available = []

for row in range(8):

for col in range(8):

piece = self.board[row][col]

if piece is not None and piece.lower() == player:

jumps = self.get_jumps_for_piece(row, col, player)

if jumps:

jumps_available.append(( (row, col), jumps ))

if jumps_available:

# Игрок должен бить. Возвращаем только взятия.

return jumps_available

else:

# Нет взятий, возвращаем простые ходы.

moves = []

for row in range(8):

for col in range(8):

piece = self.board[row][col]

if piece is not None and piece.lower() == player:

# Получим простые ходы для шашки

simple_moves = self.get_simple_moves_for_piece(row, col, player)

if simple_moves:

moves.append( ( (row, col), simple_moves ) )

return moves

def get_simple_moves_for_piece(self, row, col, player):

piece = self.board[row][col]

moves = []

if piece in ['w', 'b']:

if player == 'w':

directions = [(-1,-1), (-1,1)]

else: # 'b'

directions = [(1,-1), (1,1)]

for dr, dc in directions:

r, c = row + dr, col + dc

if 0 <= r < 8 and 0 <= c < 8 and self.board[r][c] is None:

moves.append( (r, c) )

else: # дамка

directions = [(-1,-1), (-1,1), (1,-1), (1,1)]

for dr, dc in directions:

r, c = row + dr, col + dc

while 0 <= r < 8 and 0 <= c < 8:

if self.board[r][c] is None:

moves.append( (r, c) )

r += dr

c += dc

else:

break

return moves

В методе `get_valid_moves` мы возвращаем список кортежей: (стартовая_позиция, список_ходов_из_нее)

При этом каждый ход в случае взятия - это кортеж (конечная_позиция, позиция_съеденной_шашки) для одного прыжка?

Но у нас множественные прыжки? Пока нет.

Тогда в игре:

- Показываем игроку его шашки, из которых можно ходить.

- Игрок вводит стартовую позицию.

- Показываем возможные ходы из нее (конечные позиции).

- Игрок вводит конечную позицию.

- Если ход был взятием, то удаляем съеденную шашку.

Но множественные взятия мы не поддерживаем.

Класс Game:

def __init__(self):

self.board = Board()

self.current_player = 'w'   # белые начинают

def play(self):

while not self.game_over():

self.board.print_board()

# Получаем все допустимые ходы для текущего игрока

moves = self.board.get_valid_moves(self.current_player)

# moves: список кортежей (start, moves_list), где moves_list для простых ходов - список конечных позиций, для взятий - список кортежей (end, jumped)

# Но у нас пока для взятий: moves_list = [ (end1, jumped1), (end2, jumped2), ... ]

# Сначала проверим, есть ли обязательные взятия?

jumps_available = any(isinstance(move, tuple) and len(move)==2 and isinstance(move[1], tuple) for start, moves_list in moves for move in moves_list)

# Но на самом деле, в get_valid_moves возвращает для взятий: jumps_available не пуст, и тогда moves содержит только взятия.

# Выведем:

print(f"Ход игрока: {'Белые' if self.current_player=='w' else 'Черные'}")

# Соберем все стартовые позиции, из которых можно ходить:

start_positions = [start for start, moves_list in moves if moves_list]

if not start_positions:

print("Нет доступных ходов. Игра окончена.")

break

print("Выберите шашку (строка, столбец):")

for i, (row, col) in enumerate(start_positions):

print(f"{i}: ({row}, {col})")

chosen_index = int(input("Введите номер шашки: "))

start = start_positions[chosen_index]

# Теперь покажем возможные ходы из этой шашки

# Найдем moves_list для этой шашки

for s, moves_list in moves:

if s == start:

break

print("Выберите ход (конечная позиция):")

# Если moves_list - это список кортежей (end, jumped) - значит это взятия, иначе список end - простые ходы.

# Выведем конечные позиции

# Создадим список конечных позиций

end_positions = []

if isinstance(moves_list[0], tuple) and len(moves_list[0]) == 2:

# Это список взятий: каждый элемент (end, jumped)

end_positions = [move[0] for move in moves_list]

else:

end_positions = moves_list   # список (r, c)

for i, pos in enumerate(end_positions):

print(f"{i}: {pos}")

chosen_end_index = int(input("Введите номер хода: "))

end = end_positions[chosen_end_index]

# Выполняем ход

self.board.move(start, end)

# Если это был прыжок, то удаляем съеденную шашку

if isinstance(moves_list[0], tuple) and len(moves_list[0]) == 2:

# Найдем в moves_list тот элемент, у которого end совпадает

for m in moves_list:

if m[0] == end:

jumped_pos = m[1]

self.board.remove_piece(jumped_pos)

break

# Переключаем игрока

self.current_player = 'b' if self.current_player == 'w' else 'w'

Это базовая структура. Но пока без множественных взятий.

Доработаем:

- В методе `move` класса `Board` мы не учитываем, что при прыжке шашка перемещается через клетку. Пока мы реализовали только перемещение в конечную позицию. Удаление съеденной шашки делается в классе Game.

- Добавим метод `remove_piece` в Board.

Также нужно сделать печать доски.

Из-за сложности и объема, мы не будем реализовывать множественные взятия и полные правила для дамок. Это учебный пример.

Давайте начнем писать код с учетом этих ограничений.

Важно: в шашках ходят только по черным клеткам. В нашей доске: черные клетки - это где (row+col) нечетное.

В начальной расстановке мы ставим шашки только на черные клетки.

В методе `get_simple_moves_for_piece` для дамки мы разрешаем ходить на любое количество клеток, пока пустые.

В методе `get_jumps_for_piece` для дамки мы ищем только один прыжок (без продолжения).

